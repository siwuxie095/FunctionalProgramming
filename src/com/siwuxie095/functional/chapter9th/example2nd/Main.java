package com.siwuxie095.functional.chapter9th.example2nd;

/**
 * @author Jiajing Li
 * @date 2020-10-27 21:57:11
 */
public class Main {

    /**
     * 为什么要使用非阻塞式 I/O
     *
     * 假设要编写一个支持大量用户的聊天程序。每当用户连接到聊天服务器时，都要和服务器 建立一个 TCP 连接。使用传统的线程模型，
     * 每次向用户写数据时，都要调用一个方法向用户传输数据，这个方法会阻塞当前线程。
     *
     * 这种 I/O 方式叫阻塞式 I/O，是一种通用且易于理解的方式，因为和用户的交互通常符合这样一种顺序执行的方式。缺点是:将系统
     * 扩展至支持大量用户时，需要和服务器建立大量 TCP 连接，因此扩展性不是很好。
     *
     * PS：阻塞式 I/O，也叫 阻塞 I/O。
     *
     * 非阻塞式 I/O，有时也叫异步 I/O，可以处理大量并发网络连接，而且一个线程可以为多个连接服务。和阻塞式 I/O 不同，对聊天
     * 程序客户端的读写调用立即返回，真正的读写操作则在另一个独立的线程执行，这样就可以同时执行其他任务了。如何使用这些省下来
     * 的 CPU 周期完全取决于程序员，可以选择读入更多数据，也可以玩一局游戏（玩笑话）。
     *
     * PS：非阻塞式 I/O，也叫 非阻塞 I/O。另外，非阻塞式 I/O 和异步 I/O 还是有所不同，这里将它们看作了是一个概念。
     *
     * 到目前为止，这里避免了使用代码来描述这两种 I/O 方式，因为根据 API 的不同，它们有多种实现方式。Java 标准类库的 NIO
     * 提供了非阻塞式 I/O 的接口，NIO 的最初版本用到了 Selector 的概念，让一个线程管理多个通信管道，比如向客户端写数据的
     * 网络套接字。
     *
     * 然而这种方式压根儿就没有在 Java 程序员中流行起来，它编写出来的代码难于理解和调试。引入 Lambda 表达式后，设计和实现
     * 没有这些缺点的 API 就顺手多了。
     */
    public static void main(String[] args) {

    }

}
